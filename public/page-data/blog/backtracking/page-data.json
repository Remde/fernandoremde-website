{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/backtracking/","result":{"data":{"site":{"siteMetadata":{"title":"Fernando's Website"}},"markdownRemark":{"id":"f3b237ce-3ddf-51f4-a39e-7a7587c5768b","excerpt":"”((()))”,\n  ”(()())”,\n  ”(())()”,\n  ”()(())”,\n  ”()()()”\n Seems like what we want.  If you are anything like me a few years ago, the solution below will blow…","html":"<p>It was a beautiful day in Pelotas, Brazil. I was a high school student who wanted to compete in a local programming olympiad, so I was studying the to-be-regurgitated algorithms. I came across this particular problem:\n<h3>Generate parentheses</h3>\n<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example:</p>\n<p>When n = 3, a solution set is\n<p>[\n”((()))”,\n”(()())”,\n”(())()”,\n”()(())”,\n”()()()”\n]</p>\n</p>\n<p>I don't remember exactly what I tried to do before reading the solution. Using stacks, maybe, which might even have worked. But, unbeknownst to me at the time, the best answer was something called \"backtracking.\"\n<h3>Backtracking</h3>\n<p>\"Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be completed to a valid solution.\" - Wikipedia.\n<p>Seems like what we want.</p>\n</p>\n<h3>Blueprint</h3>\n<p>We have almost always the same skeleton. Start with an empty data structure that will eventually be our final answer (in the example case, an array); an empty data structure that will be our current iteration (in the example case, a string). We call a helper function with both items, an input (in the example case, the number of parentheses n), maybe a few extras depending on the problem. On the helper function, we have a constraint. When CURRENT meets constraint, it gets added to FINAL. If it's not there yet, it calls itself again with every combination possible. Back to the main function, you return the final output.\n<p> If you are anything like me a few years ago, the solution below will blow your mind.</p></p>\n<h3>The solution</h3>\n<p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">generateParenthesis</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    output <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">#our final data structure</span>\n    <span class=\"token comment\">#input n, current string, final output, open and right parentheses count</span>\n    backtrack<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> output\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">backtrack</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\">#our constraint. when n=3, every string will have 6 parentheses.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>num<span class=\"token punctuation\">:</span>\n        output<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token comment\">#so we append it.</span>\n        <span class=\"token keyword\">return</span> output <span class=\"token comment\">#and return it.</span>\n\n    <span class=\"token comment\">#else we go to our recursive calls</span>\n    <span class=\"token comment\">#left always comes first cause it's an open parentheses</span>\n    <span class=\"token comment\">#so we update our current string with \"(\"</span>\n    <span class=\"token keyword\">if</span> left <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">:</span>\n        backtrack<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> current<span class=\"token operator\">+</span><span class=\"token string\">\"(\"</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> left<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">#and right comes after left. so we update our current with \")\"</span>\n    <span class=\"token keyword\">if</span> right <span class=\"token operator\">&lt;</span> left<span class=\"token punctuation\">:</span>\n        backtrack<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> current<span class=\"token operator\">+</span><span class=\"token string\">\")\"</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>If your mind hasn’t been blown yet, let’s try and analyze what happens here. Let’s go with n = 2 for the sake of simplicity.</p>\n<p>Call 0: backtrack function is called with num=2, current=\"\", output = [], left = 0, right = 0. Is len(current) == 2*num? No, it's 0, not 4, so we keep going. Is left less than 2? Yes, 0 < 3, so we go to our next call and this current call is now at the bottom of the stack.</p>\n<p>Call 1: backtrack function is called with num=2, current=\"(\", output=[], left=1, right = 0. len(current) < 4, but again left<num. 1 to the stack, new function called.</p>\n<p>Call 2: backtrack function is called with num=2, current=\"((\", output=[], left=2, right=0. len(current) still < 4, but this time left isn't less than 2. Is right < left? Yes. New call.</p>\n<p>Call 3: backtrack called with num=2, current=\"(()\", output=[], left=2, right=1. len(current) < 4, left == num, right < left. New call.</p>\n<p>Call 4: backtrack called with num=2, current=\"(())\", output=[], left=2, right=2. len(current) is 4, so we append it to the output and return. Back to call 3, which now ended, so back to call 2, which also ended, so back to call 1.</p>\n<p>Call 1: backtrack function had num=2, current=\"(\", output=[\"(())\"] (now updated), left=1, right=0. First condition already called, now to the second, which is true, right is less than left, so we now call again backtrack but with \"()\" as current.</p>\nYou can certainly see where this is going, so I'll stop.\n<p>Our time complexity here is O(4^n/sqrt(n)) because each valid sequence has at most n steps during the backtracking procedure. Space is also O(4^n/sqrt(n)) because of the stack.</p>\n<p></p>\n<h3>Final thoughts</h3>\n<p>Maybe I just feel nostalgic because it's the first \"hard\" algorithm I learned, but I just love backtracking. A few good problems to solve using the same principles are: Combination Sum, Find All Permutations, Letter Combinations of a Phone Number, and Find All Subsets.</p>","frontmatter":{"title":"How the backtracking algorithm works","date":"May 29, 2020","description":"Like brute force... But way cooler"}}},"pageContext":{"slug":"/blog/backtracking/","previous":{"fields":{"slug":"/blog/counting-subsequences/"},"frontmatter":{"title":"Number of distinct subsequences of string2 in string1"}},"next":{"fields":{"slug":"/blog/password-manager/"},"frontmatter":{"title":"Pass, the Password Manager"}}}}}